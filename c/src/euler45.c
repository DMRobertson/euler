//prepare: -lm

#include <stdio.h>
#include <stdbool.h>
#include <math.h>
#include <assert.h>

/* Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

Triangle   Tn=n(n+1)/2   1, 3,  6, 10, 15, ...
Pentagonal Pn=n(3n−1)/2  1, 5, 12, 22, 35, ...
Hexagonal  Hn=n(2n−1)    1, 6, 15, 28, 45, ...
It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal. */

const unsigned sides[4] = {3, 5, 6, 0};

long unsigned polygon_number(unsigned sides, long unsigned index){
	// An s-gon with sides of length n >= 1 dots takes s(n-1) dots to draw.
	// 2n - 3 are already present in an s-gon with sides consisting of n-1 dots.
	// Thus P(s, n) - P(s, n-1) = s(n-1) - (2n - 3),
	// which holds for n >= 1 if we define P(s, 0) = 0.
	// Now use this to form a telescoping sum:
	//     P(s, n) = [P(s, n) - P(s, n - 1)] + [P(s, n - 1) - P(s, n - 2)] + ... + [P(s, 1) - P(s, 0)] + P(s, 0)
	// As the last term is zero we are left with
	//    \sum_{i = 1}^n s(i-1) - (2n - 3)
	// Which simplifies to
	return (index - 1) * index * (sides - 2) / 2 + index;
}

bool is_polygon_number(unsigned sides, long unsigned value){
	long unsigned discriminant = (sides - 4) * (sides - 4) + 8 * (sides - 2) * value;
	long unsigned candidate = (long unsigned) sqrt(discriminant);
	if (candidate * candidate != discriminant){
		return false;
	}
	long unsigned numerator = sides - 4 + candidate;
	long unsigned denominator = (2 * sides - 4);
	return numerator % denominator == 0;
}

int main(){
	long unsigned T = polygon_number(3, 285);
	long unsigned P = polygon_number(5, 165);
	long unsigned H = polygon_number(6, 143);
	assert(T == 40755 && T == P && P == H);
	assert(is_polygon_number(3, T));
	assert(is_polygon_number(5, P));
	assert(is_polygon_number(6, H));
	long unsigned index = 286;
	while(true){
		T = polygon_number(6, index);
		if (is_polygon_number(5, T) && is_polygon_number(3, T)){
			break;
		}
		index++;
	}
	printf("%lu\n", T);
}